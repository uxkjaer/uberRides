/**
* This file was auto-generated by SAP Web IDE build and includes all
* the source files required by SAPUI5 runtime for performance optimization.
* PLEASE DO NOT EDIT THIS FILE!! Changes will be overwritten the next time the build is run.
*/
jQuery.sap.registerPreloadedModules({
	"version": "2.0",
	"name": "UberRides/Component-preload",
	"modules": {
		"UberRides/util/uber.js": "// Uber API Constants\nvar uberClientId = \"1XU7blOR44FyEb49TLha0tnQmLQ6CnUl\", \nuberServerToken = \"J6dLLGK_M6dqdfTz4BQnVgKuJ5fp7BW2O188OVty\";\n\n\n\nfunction getHistory() {\n  $.ajax({\n    url: \"/Uber_Api/v1.2/history\",\n    headers: {\n        Authorization: \"Token \"  +uberServerToken\n    }\n    ,\n    success: function(result) {\n      console.log(result);\n    }\n  });\n}",
		"UberRides/util/jso.js": "(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        //Allow using this built library as an AMD module\n        //in another project. That other project will only\n        //see this AMD call, not the internal modules in\n        //the closure below.\n        define([], factory);\n    } else {\n        //Browser globals case. Just assign the\n        //result to a property on the global.\n        root.JSO = factory();\n    }\n}(this, function () {\n    //almond, and your modules will be inlined here\n/**\n * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice,\n        jsSuffixRegExp = /\\.js$/;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName's\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n                name = name.split('/');\n                lastIndex = name.length - 1;\n\n                // Node .js allowance:\n                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n                }\n\n                name = baseParts.concat(name);\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            callbackType = typeof callback,\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (callbackType === 'undefined' || callbackType === 'function') {\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback ? callback.apply(defined[name], args) : undefined;\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (config.deps) {\n                req(config.deps, config.callback);\n            }\n            if (!callback) {\n                return;\n            }\n\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        return req(cfg);\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"almond\", function(){});\n\ndefine('utils',['require','exports','module'],function(require, exports, module) {\n\n\n\tvar utils = {};\n\n\n\t/*\n\t * Returns epoch, seconds since 1970.\n\t * Used for calculation of expire times.\n\t */\n\tutils.epoch = function() {\n\t\treturn Math.round(new Date().getTime()/1000.0);\n\t};\n\n\n\t/*\n\t * Returns a random string used for state\n\t */\n\tutils.uuid = function() {\n\t\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    \t\tvar r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n\t\t    return v.toString(16);\n\t\t});\n\t};\n\n\n\n\tutils.parseQueryString = function (qs) {\n\t\tvar e,\n\t\t\ta = /\\+/g,  // Regex for replacing addition symbol with a space\n\t\t\tr = /([^&;=]+)=?([^&;]*)/g,\n\t\t\td = function (s) { return decodeURIComponent(s.replace(a, \" \")); },\n\t\t\tq = qs,\n\t\t\turlParams = {};\n\n\t\t/* jshint ignore:start */\n\t\twhile (e = r.exec(q)) {\n\t\t   urlParams[d(e[1])] = d(e[2]);\n\t\t};\n\t\t/* jshint ignore:end */\n\n\t\treturn urlParams;\n\t};\n\n\n\n\n\n\t/**\n\t * Utility: scopeList(scopes )\n\t * Takes a list of scopes that might be overlapping, and removed duplicates,\n\t * then concatenates the list by spaces and returns a string.\n\t * \n\t * @param  {[type]} scopes [description]\n\t * @return {[type]}        [description]\n\t */\n\tutils.scopeList = function(scopes) {\n\t\treturn utils.uniqueList(scopes).join(' ');\n\t};\n\n\n\tutils.uniqueList = function(items) {\n\t\tvar uniqueItems = {};\n\t\tvar resultItems = [];\n\t\tfor(var i = 0; i < items.length; i++) {\n\t\t\tuniqueItems[items[i]] = 1;\n\t\t}\n\t\tfor(var key in uniqueItems) {\n\t\t\tif (uniqueItems.hasOwnProperty(key)) {\n\t\t\t\tresultItems.push(key);\n\t\t\t}\n\t\t}\n\t\treturn resultItems;\n\t};\n\n\n\n\n\n\t/*\n\t * Returns a random string used for state\n\t */\n\tutils.uuid = function() {\n\t\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t\t\tvar r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n\t\t\treturn v.toString(16);\n\t\t});\n\t};\n\n\t/**\n\t * A log wrapper, that only logs if logging is turned on in the config\n\t * @param  {string} msg Log message\n\t */\n\tutils.log = function(msg) {\n\t\t// if (!options.debug) return;\n\t\tif (!console) return;\n\t\tif (!console.log) return;\n\n\t\t// console.log(\"LOG(), Arguments\", arguments, msg)\n\t\tif (arguments.length > 1) {\n\t\t\tconsole.log(arguments);\t\n\t\t} else {\n\t\t\tconsole.log(msg);\n\t\t}\n\t\t\n\t};\n\n\t/**\n\t * Set the global options.\n\t */\n\t// utils.setOptions = function(opts) {\n\t// \tif (!opts) return;\n\t// \tfor(var k in opts) {\n\t// \t\tif (opts.hasOwnProperty(k)) {\n\t// \t\t\toptions[k] = opts[k];\n\t// \t\t}\n\t// \t}\n\t// \tlog(\"Options is set to \", options);\n\t// }\n\n\n\t/* \n\t * Takes an URL as input and a params object.\n\t * Each property in the params is added to the url as query string parameters\n\t */\n\tutils.encodeURL = function(url, params) {\n\t\tvar res = url;\n\t\tvar k, i = 0;\n\t\tvar firstSeparator = (url.indexOf(\"?\") === -1) ? '?' : '&';\n\t\tfor(k in params) {\n\t\t\tres += (i++ === 0 ? firstSeparator : '&') + encodeURIComponent(k) + '=' + encodeURIComponent(params[k]);\n\t\t}\n\t\treturn res;\n\t};\n\n\t/*\n\t * Returns epoch, seconds since 1970.\n\t * Used for calculation of expire times.\n\t */\n\tutils.epoch = function() {\n\t\treturn Math.round(new Date().getTime()/1000.0);\n\t};\n\n\n\n\n\treturn utils;\n\n});\n//define(['utils'], function(utils) {\n\ndefine('store',['require','exports','module','./utils'],function(require, exports, module) {\n\n\tvar utils = require('./utils');\n\tvar store = {};\n\n\n\t/**\n\t\tsaveState stores an object with an Identifier.\n\t\tTODO: Ensure that both localstorage and JSON encoding has fallbacks for ancient browsers.\n\t\tIn the state object, we put the request object, plus these parameters:\n\t\t  * restoreHash\n\t\t  * providerID\n\t\t  * scopes\n\n\t */\n\tstore.saveState = function (state, obj) {\n\t\tlocalStorage.setItem(\"state-\" + state, JSON.stringify(obj));\n\t};\n\t\n\t/**\n\t * getStage()  returns the state object, but also removes it.\n\t * @type {Object}\n\t */\n\tstore.getState = function(state) {\n\t\t// log(\"getState (\" + state+ \")\");\n\t\tvar obj = JSON.parse(localStorage.getItem(\"state-\" + state));\n\t\tlocalStorage.removeItem(\"state-\" + state);\n\t\treturn obj;\n\t};\n\n\n\t/**\n\t * A log wrapper, that only logs if logging is turned on in the config\n\t * @param  {string} msg Log message\n\t */\n\tvar log = function(msg) {\n\t\t// if (!options.debug) return;\n\t\tif (!console) return;\n\t\tif (!console.log) return;\n\n\t\t// console.log(\"LOG(), Arguments\", arguments, msg)\n\t\tif (arguments.length > 1) {\n\t\t\tconsole.log(arguments);\t\n\t\t} else {\n\t\t\tconsole.log(msg);\n\t\t}\n\t\t\n\t};\n\n\n\t/*\n\t * Checks if a token, has includes a specific scope.\n\t * If token has no scope at all, false is returned.\n\t */\n\tstore.hasScope = function(token, scope) {\n\t\tvar i;\n\t\tif (!token.scopes) return false;\n\t\tfor(i = 0; i < token.scopes.length; i++) {\n\t\t\tif (token.scopes[i] === scope) return true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/*\n\t * Takes an array of tokens, and removes the ones that\n\t * are expired, and the ones that do not meet a scopes requirement.\n\t */\n\tstore.filterTokens = function(tokens, scopes) {\n\t\tvar i, j, \n\t\t\tresult = [],\n\t\t\tnow = utils.epoch(),\n\t\t\tusethis;\n\n\t\tif (!scopes) scopes = [];\n\n\t\tfor(i = 0; i < tokens.length; i++) {\n\t\t\tusethis = true;\n\n\t\t\t// Filter out expired tokens. Tokens that is expired in 1 second from now.\n\t\t\tif (tokens[i].expires && tokens[i].expires < (now+1)) usethis = false;\n\n\t\t\t// Filter out this token if not all scope requirements are met\n\t\t\tfor(j = 0; j < scopes.length; j++) {\n\t\t\t\tif (!store.hasScope(tokens[i], scopes[j])) usethis = false;\n\t\t\t}\n\n\t\t\tif (usethis) result.push(tokens[i]);\n\t\t}\n\t\treturn result;\n\t};\n\n\n\t/*\n\t * saveTokens() stores a list of tokens for a provider.\n\n\t\tUsually the tokens stored are a plain Access token plus:\n\t\t  * expires : time that the token expires\n\t\t  * providerID: the provider of the access token?\n\t\t  * scopes: an array with the scopes (not string)\n\t */\n\tstore.saveTokens = function(provider, tokens) {\n\t\t// log(\"Save Tokens (\" + provider+ \")\");\n\t\tlocalStorage.setItem(\"tokens-\" + provider, JSON.stringify(tokens));\n\t};\n\n\tstore.getTokens = function(provider) {\n\t\t// log(\"Get Tokens (\" + provider+ \")\");\n\t\tvar tokens = JSON.parse(localStorage.getItem(\"tokens-\" + provider));\n\t\tif (!tokens) tokens = [];\n\n\t\tlog(\"Token received\", tokens);\n\t\treturn tokens;\n\t};\n\tstore.wipeTokens = function(provider) {\n\t\tlocalStorage.removeItem(\"tokens-\" + provider);\n\t};\n\t/*\n\t * Save a single token for a provider.\n\t * This also cleans up expired tokens for the same provider.\n\t */\n\tstore.saveToken = function(provider, token) {\n\t\tvar tokens = this.getTokens(provider);\n\t\ttokens = store.filterTokens(tokens);\n\t\ttokens.push(token);\n\t\tthis.saveTokens(provider, tokens);\n\t};\n\n\t/*\n\t * Get a token if exists for a provider with a set of scopes.\n\t * The scopes parameter is OPTIONAL.\n\t */\n\tstore.getToken = function(provider, scopes) {\n\t\tvar tokens = this.getTokens(provider);\n\t\ttokens = store.filterTokens(tokens, scopes);\n\t\tif (tokens.length < 1) return null;\n\t\treturn tokens[0];\n\t};\n\n\n\n\treturn store;\n});\n\ndefine('Config',[],function() {\n\t// Credits to Ryan Lynch\n\t// http://stackoverflow.com/questions/11197247/javascript-equivalent-of-jquerys-extend-method\n\tvar extend = function (a){\n\t\tfor(var i=1; i<a.length; i++)\n\t\t\tfor(var key in a[i])\n\t\t\t\tif(a[i].hasOwnProperty(key))\n\t\t\t\t\ta[0][key] = a[i][key];\n\t\treturn a[0];\n\t};\n\n\n\tvar Config = function() {\n\t\tvar ca = [{}];\n\t\tfor(var i = 0; i < arguments.length; i++) {\n\t\t\tca.push(arguments[i]);\n\t\t}\n\t\tthis.config = extend(ca);\n\t};\n\n\tConfig.prototype.has = function(key) {\n\t\tvar pointer = this.config;\n\t\tvar splittedKeys = key.split('.');\n\t\tvar i = 0;\n\n\t\tfor(i = 0; i < splittedKeys.length; i++) {\n\t\t\tif (pointer.hasOwnProperty(splittedKeys[i])) {\n\t\t\t\tpointer = pointer[splittedKeys[i]];\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\tConfig.prototype.get = function(key, defaultValue, isRequired) {\n\n\t\t// console.log(\"about to load config\", key, this.config);\n\n\t\tisRequired = isRequired || false;\n\n\t\tvar pointer = this.config;\n\n\t\tvar splittedKeys = key.split('.');\n\t\tvar i = 0;\n\n\t\t// console.log(\"splittedKeys\", splittedKeys); \n\n\t\tfor(i = 0; i < splittedKeys.length; i++) {\n\n\t\t\tif (pointer.hasOwnProperty(splittedKeys[i])) {\n\t\t\t\t// console.log(\"POINTING TO \" + splittedKeys[i]);\n\t\t\t\tpointer = pointer[splittedKeys[i]];\n\t\t\t} else {\n\t\t\t\tpointer = undefined;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof pointer === 'undefined') {\n\t\t\tif (isRequired) {\n\t\t\t\tthrow new Error(\"Configuration option [\" + splittedKeys[i] + \"] required but not provided.\");\n\t\t\t}\n\t\t\treturn defaultValue;\n\t\t}\n\t\treturn pointer;\n\t};\n\n\treturn Config;\n});\n/**\n * JSO - Javascript OAuth Library\n * \tVersion 2.0\n *  UNINETT AS - http://uninett.no\n *  Author: Andreas Ã…kre Solberg <andreas.solberg@uninett.no>\n *  Licence: \n *   \t\n *  Documentation available at: https://github.com/andreassolberg/jso\n */\n\ndefine('jso',['require','exports','module','./store','./utils','./Config'],function(require, exports, module) {\n\n\tvar \n\t\tdefault_config = {\n\t\t\t\"lifetime\": 3600,\n\t\t\t\"debug\": true,\n\t\t\t\"foo\": {\n\t\t\t\t\"bar\": \"lsdkjf\"\n\t\t\t}\n\t\t};\n\n\tvar store = require('./store');\n\tvar utils = require('./utils');\n\tvar Config = require('./Config');\n\n\n\n\n\n\tvar JSO = function(config) {\n\n\t\tthis.config = new Config(default_config, config);\n\t\tthis.providerID = this.getProviderID();\n\n\t\tJSO.instances[this.providerID] = this;\n\n\t\tthis.callbacks = {};\n\n\t\tthis.callbacks.redirect = JSO.redirect;\n\n\t\t// console.log(\"Testing configuration object\");\n\t\t// console.log(\"foo.bar.baz (2,false)\", this.config.get('foo.bar.baz', 2 ) );\n\t\t// console.log(\"foo.bar.baz (2,true )\", this.config.get('foo.bar.baz', 2, true ) );\n\t};\n\n\tJSO.internalStates = [];\n\tJSO.instances = {};\n\tJSO.store = store;\n\tJSO.utils = utils;\n\n\tconsole.log(\"RESET internalStates array\");\n\n\n\tJSO.enablejQuery = function($) {\n\t\tJSO.$ = $;\n\t};\n\n\n\tJSO.redirect = function(url, callback) {\n\t\twindow.location = url;\n\t};\n\n\tJSO.prototype.inappbrowser = function(params) {\n\t\tvar that = this;\n\t\treturn function(url, callback) {\n\n\n\t        var onNewURLinspector = function(ref) {\n\t        \treturn function(inAppBrowserEvent) {\n\n\t\t            //  we'll check the URL for oauth fragments...\n\t\t            var url = inAppBrowserEvent.url;\n\t\t            utils.log(\"loadstop event triggered, and the url is now \" + url);\n\n\t\t            if (that.URLcontainsToken(url)) {\n\t\t                // ref.removeEventListener('loadstop', onNewURLinspector);\n\t\t                setTimeout(function() {\n\t\t                \tref.close();\n\t\t                }, 500);\n\t\t                \n\n\t\t\t            that.callback(url, function() {\n\t\t\t                // When we've found OAuth credentials, we close the inappbrowser...\n\t\t\t                utils.log(\"Closing window \", ref);\n\t\t\t                if (typeof callback === 'function') callback();\n\t\t\t            });\t            \t\n\t\t            }\n\t\t            \n\t\t        };\n\t\t    };\n\n\t\t\tvar target = '_blank';\n\t\t\tif (params.hasOwnProperty('target')) {\n\t\t\t\ttarget = params.target;\n\t\t\t}\n\t\t\tvar options = {};\n\n\t\t\tutils.log(\"About to open url \" + url);\n\n\t\t\tvar ref = window.open(url, target, options);\n\t\t\tutils.log(\"URL Loaded... \");\n\t        ref.addEventListener('loadstart', onNewURLinspector(ref));\n\t        utils.log(\"Event listeren ardded... \", ref);\n\t        \n\n\t        // Everytime the Phonegap InAppBrowsers moves to a new URL,\n\t        \n\n\n\t\t};\n\t};\n\n\tJSO.prototype.on = function(eventid, callback) {\n\t\tif (typeof eventid !== 'string') throw new Error('Registering triggers on JSO must be identified with an event id');\n\t\tif (typeof callback !== 'function') throw new Error('Registering a callback on JSO must be a function.');\n\n\t\tthis.callbacks[eventid] = callback;\n\t};\n\n\n\t/**\n\t * We need to get an identifier to represent this OAuth provider.\n\t * The JSO construction option providerID is preferred, if not provided\n\t * we construct a concatentaion of authorization url and client_id.\n\t * @return {[type]} [description]\n\t */\n\tJSO.prototype.getProviderID = function() {\n\n\t\tvar c = this.config.get('providerID', null);\n\t\tif (c !== null) return c;\n\n\t\tvar client_id = this.config.get('client_id', null, true);\n\t\tvar authorization = this.config.get('authorization', null, true);\n\n\t\treturn authorization + '|' + client_id;\n\t};\n\n\n\n\n\t/**\n\t * Do some sanity checking whether an URL contains a access_token in an hash fragment.\n\t * Used in URL change event trackers, to detect responses from the provider.\n\t * @param {[type]} url [description]\n\t */\n\tJSO.prototype.URLcontainsToken = function(url) {\n\t\t// If a url is provided \n\t\tif (url) {\n\t\t\t// utils.log('Hah, I got the url and it ' + url);\n\t\t\tif(url.indexOf('#') === -1) return false;\n\t\t\th = url.substring(url.indexOf('#'));\n\t\t\t// utils.log('Hah, I got the hash and it is ' +  h);\n\t\t}\n\n\t\t/*\n\t\t * Start with checking if there is a token in the hash\n\t\t */\n\t\tif (h.length < 2) return false;\n\t\tif (h.indexOf(\"access_token\") === -1) return false;\n\t\treturn true;\n\t};\n\n\t/**\n\t * Check if the hash contains an access token. \n\t * And if it do, extract the state, compare with\n\t * config, and store the access token for later use.\n\t *\n\t * The url parameter is optional. Used with phonegap and\n\t * childbrowser when the jso context is not receiving the response,\n\t * instead the response is received on a child browser.\n\t */\n\tJSO.prototype.callback = function(url, callback, providerID) {\n\t\tvar \n\t\t\tatoken,\n\t\t\th = window.location.hash,\n\t\t\tnow = utils.epoch(),\n\t\t\tstate,\n\t\t\tinstance;\n\n\t\tutils.log(\"JSO.prototype.callback() \" + url + \" callback=\" + typeof callback);\n\n\t\t// If a url is provided \n\t\tif (url) {\n\t\t\t// utils.log('Hah, I got the url and it ' + url);\n\t\t\tif(url.indexOf('#') === -1) return;\n\t\t\th = url.substring(url.indexOf('#'));\n\t\t\t// utils.log('Hah, I got the hash and it is ' +  h);\n\t\t}\n\n\t\t/*\n\t\t * Start with checking if there is a token in the hash\n\t\t */\n\t\tif (h.length < 2) return;\n\t\tif (h.indexOf(\"access_token\") === -1) return;\n\t\th = h.substring(1);\n\t\tatoken = utils.parseQueryString(h);\n\n\t\tif (atoken.state) {\n\t\t\tstate = store.getState(atoken.state);\n\t\t} else {\n\t\t\tif (!providerID) {throw \"Could not get [state] and no default providerid is provided.\";}\n\t\t\tstate = {providerID: providerID};\n\t\t}\n\n\t\t\n\t\tif (!state) throw \"Could not retrieve state\";\n\t\tif (!state.providerID) throw \"Could not get providerid from state\";\n\t\tif (!JSO.instances[state.providerID]) throw \"Could not retrieve JSO.instances for this provider.\";\n\t\t\n\t\tinstance = JSO.instances[state.providerID];\n\n\t\t/**\n\t\t * If state was not provided, and default provider contains a scope parameter\n\t\t * we assume this is the one requested...\n\t\t */\n\t\tif (!atoken.state && co.scope) {\n\t\t\tstate.scopes = instance._getRequestScopes();\n\t\t\tutils.log(\"Setting state: \", state);\n\t\t}\n\t\tutils.log(\"Checking atoken \", atoken, \" and instance \", instance);\n\n\t\t/*\n\t\t * Decide when this token should expire.\n\t\t * Priority fallback:\n\t\t * 1. Access token expires_in\n\t\t * 2. Life time in config (may be false = permanent...)\n\t\t * 3. Specific permanent scope.\n\t\t * 4. Default library lifetime:\n\t\t */\n\t\tif (atoken.expires_in) {\n\t\t\tatoken.expires = now + parseInt(atoken.expires_in, 10);\n\t\t} else if (instance.config.get('default_lifetime', null) === false) {\n\t\t\t// Token is permanent.\n\t\t} else if (instance.config.has('permanent_scope')) {\n\t\t\tif (!store.hasScope(atoken, instance.config.get('permanent_scope'))) {\n\t\t\t\tatoken.expires = now + 3600*24*365*5;\n\t\t\t}\n\t\t} else if (instance.config.has('default_lifetime')) {\n\t\t\tatoken.expires = now + instance.config.get('default_lifetime');\n\t\t} else {\n\t\t\tatoken.expires = now + 3600;\n\t\t}\n\n\t\t/*\n\t\t * Handle scopes for this token\n\t\t */\n\t\tif (atoken.scope) {\n\t\t\tatoken.scopes = atoken.scope.split(\" \");\n\t\t} else if (state.scopes) {\n\t\t\tatoken.scopes = state.scopes;\n\t\t}\n\n\n\n\t\tstore.saveToken(state.providerID, atoken);\n\n\t\tif (state.restoreHash) {\n\t\t\twindow.location.hash = state.restoreHash;\n\t\t} else {\n\t\t\twindow.location.hash = '';\n\t\t}\n\n\n\t\tutils.log(atoken);\n\n\t\tutils.log(\"Looking up internalStates storage for a stored callback... \", \"state=\" + atoken.state, JSO.internalStates);\n\n\t\tif (JSO.internalStates[atoken.state] && typeof JSO.internalStates[atoken.state] === 'function') {\n\t\t\tutils.log(\"InternalState is set, calling it now!\");\n\t\t\tJSO.internalStates[atoken.state](atoken);\n\t\t\tdelete JSO.internalStates[atoken.state];\n\t\t}\n\n\n\t\tutils.log(\"Successfully obtain a token, now call the callback, and may be the window closes\", callback);\n\n\t\tif (typeof callback === 'function') {\n\t\t\tcallback(atoken);\n\t\t}\n\n\t\t// utils.log(atoken);\n\n\t};\n\n\tJSO.prototype.dump = function() {\n\n\t\tvar txt = '';\n\t\tvar tokens = store.getTokens(this.providerID);\n\t\ttxt += 'Tokens: ' + \"\\n\" + JSON.stringify(tokens, undefined, 4) + '\\n\\n';\n\t\ttxt += 'Config: ' + \"\\n\" + JSON.stringify(this.config, undefined, 4) + \"\\n\\n\";\n\t\treturn txt;\n\t};\n\n\tJSO.prototype._getRequestScopes = function(opts) {\n\t\tvar scopes = [], i;\n\t\t/*\n\t\t * Calculate which scopes to request, based upon provider config and request config.\n\t\t */\n\t\tif (this.config.get('scopes') && this.config.get('scopes').request) {\n\t\t\tfor(i = 0; i < this.config.get('scopes').request.length; i++) scopes.push(this.config.get('scopes').request[i]);\n\t\t}\n\t\tif (opts && opts.scopes && opts.scopes.request) {\n\t\t\tfor(i = 0; i < opts.scopes.request.length; i++) scopes.push(opts.scopes.request[i]);\n\t\t}\n\t\treturn utils.uniqueList(scopes);\n\t};\n\n\tJSO.prototype._getRequiredScopes = function(opts) {\n\t\tvar scopes = [], i;\n\t\t/*\n\t\t * Calculate which scopes to request, based upon provider config and request config.\n\t\t */\n\t\tif (this.config.get('scopes') && this.config.get('scopes').require) {\n\t\t\tfor(i = 0; i < this.config.get('scopes').require.length; i++) scopes.push(this.config.get('scopes').require[i]);\n\t\t}\n\t\tif (opts && opts.scopes && opts.scopes.require) {\n\t\t\tfor(i = 0; i < opts.scopes.require.length; i++) scopes.push(opts.scopes.require[i]);\n\t\t}\n\t\treturn utils.uniqueList(scopes);\n\t};\n\n\tJSO.prototype.getToken = function(callback, opts) {\n\t\t// var scopesRequest  = this._getRequestScopes(opts);\n\t\t\n\t\tvar scopesRequire = this._getRequiredScopes(opts);\n\t\tvar token = store.getToken(this.providerID, scopesRequire);\n\n\t\tif (token) {\n\t\t\treturn callback(token);\n\t\t} else {\n\t\t\tthis._authorize(callback, opts);\n\t\t}\n\n\t};\n\n\tJSO.prototype.checkToken = function(opts) {\n\t\t// var scopesRequest  = this._getRequestScopes(opts);\n\t\t\n\t\tvar scopesRequire = this._getRequiredScopes(opts);\n\t\treturn store.getToken(this.providerID, scopesRequire);\n\t};\n\n\n\t// exp.jso_ensureTokens = function (ensure) {\n\t// \tvar providerid, scopes, token;\n\t// \tfor(providerid in ensure) {\n\t// \t\tscopes = undefined;\n\t// \t\tif (ensure[providerid]) scopes = ensure[providerid];\n\t// \t\ttoken = store.getToken(providerid, scopes);\n\n\t// \t\tutils.log(\"Ensure token for provider [\" + providerid + \"] \");\n\t// \t\tutils.log(token);\n\n\t// \t\tif (token === null) {\n\t// \t\t\tjso_authrequest(providerid, scopes);\n\t// \t\t}\n\t// \t}\n\n\n\t// \treturn true;\n\t// }\n\n\n\tJSO.prototype._authorize = function(callback, opts) {\n\t\tvar \n\t\t\trequest,\n\t\t\tauthurl,\n\t\t\tscopes;\n\n\t\tvar authorization = this.config.get('authorization', null, true);\n\t\tvar client_id = this.config.get('client_id', null, true);\n\n\t\tutils.log(\"About to send an authorization request to this entry:\", authorization);\n\t\tutils.log(\"Options\", opts, \"callback\", callback);\n\n\n\t\trequest = {\n\t\t\t\"response_type\": \"token\",\n\t\t\t\"state\": utils.uuid()\n\t\t};\n\n\n\n\t\tif (callback && typeof callback === 'function') {\n\t\t\tutils.log(\"About to store a callback for later with state=\" + request.state, callback);\n\t\t\tJSO.internalStates[request.state] = callback;\n\t\t}\n\n\t\tif (this.config.has('redirect_uri')) {\n\t\t\trequest.redirect_uri = this.config.get('redirect_uri', '');\n\t\t}\n\n\t\trequest.client_id = client_id;\n\n\n\n\t\t/*\n\t\t * Calculate which scopes to request, based upon provider config and request config.\n\t\t */\n\t\tscopes = this._getRequestScopes(opts);\n\t\tif (scopes.length > 0) {\n\t\t\trequest.scope = utils.scopeList(scopes);\n\t\t}\n\n\t\tutils.log(\"DEBUG REQUEST\"); utils.log(request);\n\n\t\tauthurl = utils.encodeURL(authorization, request);\n\n\t\t// We'd like to cache the hash for not loosing Application state. \n\t\t// With the implciit grant flow, the hash will be replaced with the access\n\t\t// token when we return after authorization.\n\t\tif (window.location.hash) {\n\t\t\trequest.restoreHash = window.location.hash;\n\t\t}\n\t\trequest.providerID = this.providerID;\n\t\tif (scopes) {\n\t\t\trequest.scopes = scopes;\n\t\t}\n\n\n\t\tutils.log(\"Saving state [\" + request.state + \"]\");\n\t\tutils.log(JSON.parse(JSON.stringify(request)));\n\n\t\tstore.saveState(request.state, request);\n\t\tthis.gotoAuthorizeURL(authurl, callback);\n\t};\n\n\n\tJSO.prototype.gotoAuthorizeURL = function(url, callback) {\n\n\n\t\tif (!this.callbacks.redirect || typeof this.callbacks.redirect !== 'function') \n\t\t\tthrow new Error('Cannot redirect to authorization endpoint because of missing redirect handler');\n\n\t\tthis.callbacks.redirect(url, callback);\n\n\t};\n\n\tJSO.prototype.wipeTokens = function() {\n\t\tstore.wipeTokens(this.providerID);\n\t};\n\n\n\tJSO.prototype.ajax = function(settings) {\n\n\t\tvar \n\t\t\tallowia,\n\t\t\tscopes,\n\t\t\ttoken,\n\t\t\tproviderid,\n\t\t\tco;\n\n\t\tvar that = this;\n\n\t\tif (!JSO.hasOwnProperty('$')) throw new Error(\"JQuery support not enabled.\");\n\t\t\n\t\toauthOptions = settings.oauth || {};\n\n\t\tvar errorOverridden = settings.error || null;\n\t\tsettings.error = function(jqXHR, textStatus, errorThrown) {\n\t\t\tutils.log('error(jqXHR, textStatus, errorThrown)');\n\t\t\tutils.log(jqXHR);\n\t\t\tutils.log(textStatus);\n\t\t\tutils.log(errorThrown);\n\n\t\t\tif (jqXHR.status === 401) {\n\n\t\t\t\tutils.log(\"Token expired. About to delete this token\");\n\t\t\t\tutils.log(token);\n\t\t\t\tthat.wipeTokens();\n\n\t\t\t}\n\t\t\tif (errorOverridden && typeof errorOverridden === 'function') {\n\t\t\t\terrorOverridden(jqXHR, textStatus, errorThrown);\n\t\t\t}\n\t\t};\n\n\n\t\treturn this.getToken(function(token) {\n\t\t\tutils.log(\"Ready. Got an token, and ready to perform an AJAX call\", token);\n\n\t\t\tif (that.config.get('presenttoken', null) === 'qs') {\n\t\t\t\t// settings.url += ((h.indexOf(\"?\") === -1) ? '?' : '&') + \"access_token=\" + encodeURIComponent(token[\"access_token\"]);\n\t\t\t\tif (!settings.data) settings.data = {};\n\t\t\t\tsettings.data.access_token = token.access_token;\n\t\t\t} else {\n\t\t\t\tif (!settings.headers) settings.headers = {};\n\t\t\t\tsettings.headers.Authorization = \"Bearer \" + token.access_token;\n\t\t\t}\n\t\t\tutils.log('$.ajax settings', settings);\n\t\t\treturn JSO.$.ajax(settings);\n\n\t\t}, oauthOptions);\n\t\t\n\t};\n\n\n\n\n\n\t/* \n\t * Redirects the user to a specific URL\n\t */\n\t// api_redirect = function(url) {\n\t// \tsetTimeout(function() {\n\t// \t\twindow.location = url;\n\t// \t}, 2000);\n\t// };\n\n\n\n\n\n\n\n\n\n\n\t// exp.jso_ensureTokens = function (ensure) {\n\t// \tvar providerid, scopes, token;\n\t// \tfor(providerid in ensure) {\n\t// \t\tscopes = undefined;\n\t// \t\tif (ensure[providerid]) scopes = ensure[providerid];\n\t// \t\ttoken = store.getToken(providerid, scopes);\n\n\t// \t\tutils.log(\"Ensure token for provider [\" + providerid + \"] \");\n\t// \t\tutils.log(token);\n\n\t// \t\tif (token === null) {\n\t// \t\t\tjso_authrequest(providerid, scopes);\n\t// \t\t}\n\t// \t}\n\n\n\t// \treturn true;\n\t// }\n\n\n\t// exp.jso_configure = function(c, opts) {\n\t// \tconfig = c;\n\t// \tsetOptions(opts);\n\t// \ttry {\n\n\t// \t\tvar def = exp.jso_findDefaultEntry(c);\n\t// \t\tutils.log(\"jso_configure() about to check for token for this entry\", def);\n\t// \t\texp.jso_checkfortoken(def);\t\n\n\t// \t} catch(e) {\n\t// \t\tutils.log(\"Error when retrieving token from hash: \" + e, c, opts);\n\t// \t\twindow.location.hash = \"\";\n\t// \t}\n\t\t\n\t// }\n\n\t// exp.jso_dump = function() {\n\t// \tvar key;\n\t// \tfor(key in config) {\n\n\t// \t\tutils.log(\"=====> Processing provider [\" + key + \"]\");\n\t// \t\tutils.log(\"=] Config\");\n\t// \t\tutils.log(config[key]);\n\t// \t\tutils.log(\"=] Tokens\")\n\t// \t\tutils.log(store.getTokens(key));\n\n\t// \t}\n\t// }\n\n\t// exp.jso_wipe = function() {\n\t// \tvar key;\n\t// \tutils.log(\"jso_wipe()\");\n\t// \tfor(key in config) {\n\t// \t\tutils.log(\"Wipping tokens for \" + key);\n\t// \t\tstore.wipeTokens(key);\n\t// \t}\n\t// }\n\n\t// exp.jso_getToken = function(providerid, scopes) {\n\t// \tvar token = store.getToken(providerid, scopes);\n\t// \tif (!token) return null;\n\t// \tif (!token[\"access_token\"]) return null;\n\t// \treturn token[\"access_token\"];\n\t// }\n\n\n\n\n\n\n\n\n\n\n\t// /*\n\t//  * From now on, we only perform tasks that require jQuery.\n\t//  * Like adding the $.oajax function.\n\t//  */\n\t// if (typeof $ === 'undefined') return;\n\n\t// $.oajax = function(settings) {\n\t// \tvar \n\t// \t\tallowia,\n\t// \t\tscopes,\n\t// \t\ttoken,\n\t// \t\tproviderid,\n\t// \t\tco;\n\t\t\n\t// \tproviderid = settings.jso_provider;\n\t// \tallowia = settings.jso_allowia || false;\n\t// \tscopes = settings.jso_scopes;\n\t// \ttoken = api_storage.getToken(providerid, scopes);\n\t// \tco = config[providerid];\n\n\t// \t// var successOverridden = settings.success;\n\t// \t// settings.success = function(response) {\n\t// \t// }\n\n\t// \tvar errorOverridden = settings.error || null;\n\n\t// \tvar performAjax = function() {\n\t// \t\t// utils.log(\"Perform ajax!\");\n\n\t// \t\tif (!token) throw \"Could not perform AJAX call because no valid tokens was found.\";\t\n\n\t// \t\tif (co[\"presenttoken\"] && co[\"presenttoken\"] === \"qs\") {\n\t// \t\t\t// settings.url += ((h.indexOf(\"?\") === -1) ? '?' : '&') + \"access_token=\" + encodeURIComponent(token[\"access_token\"]);\n\t// \t\t\tif (!settings.data) settings.data = {};\n\t// \t\t\tsettings.data[\"access_token\"] = token[\"access_token\"];\n\t// \t\t} else {\n\t// \t\t\tif (!settings.headers) settings.headers = {};\n\t// \t\t\tsettings.headers[\"Authorization\"] = \"Bearer \" + token[\"access_token\"];\n\t// \t\t}\n\t// \t\t$.ajax(settings);\n\t// \t};\n\n\t// \tsettings.error = function(jqXHR, textStatus, errorThrown) {\n\t// \t\tutils.log('error(jqXHR, textStatus, errorThrown)');\n\t// \t\tutils.log(jqXHR);\n\t// \t\tutils.log(textStatus);\n\t// \t\tutils.log(errorThrown);\n\n\t// \t\tif (jqXHR.status === 401) {\n\n\t// \t\t\tutils.log(\"Token expired. About to delete this token\");\n\t// \t\t\tutils.log(token);\n\t// \t\t\tapi_storage.wipeTokens(providerid);\n\n\t// \t\t}\n\t// \t\tif (errorOverridden && typeof errorOverridden === 'function') {\n\t// \t\t\terrorOverridden(jqXHR, textStatus, errorThrown);\n\t// \t\t}\n\t// \t}\n\n\n\t// \tif (!token) {\n\t// \t\tif (allowia) {\n\t// \t\t\tutils.log(\"Perform authrequest\");\n\t// \t\t\tjso_authrequest(providerid, scopes, function() {\n\t// \t\t\t\ttoken = api_storage.getToken(providerid, scopes);\n\t// \t\t\t\tperformAjax();\n\t// \t\t\t});\n\t// \t\t\treturn;\n\t// \t\t} else {\n\t// \t\t\tthrow \"Could not perform AJAX call because no valid tokens was found.\";\t\n\t// \t\t}\n\t// \t}\n\n\n\t// \tperformAjax();\n\t// };\n\n\treturn JSO;\n\n\n});\n\n    //The modules for your project will be inlined above\n    //this snippet. Ask almond to synchronously require the\n    //module value for 'main' here and return it as the\n    //value to use for the public API for the built file.\n    return require('jso');\n}));",
		"UberRides/Component.js": "sap.ui.define([\n\t\"sap/ui/core/UIComponent\",\n\t\"sap/ui/Device\",\n\t\"UberRides/model/models\"\n], function(UIComponent, Device, models) {\n\t\"use strict\";\n\n\treturn UIComponent.extend(\"UberRides.Component\", {\n\t\tmetadata: {\n\t\t\tmanifest: \"json\"\n\t\t},\n\t\t\n\t\n\t\t/**\n\t\t * The component is initialized by UI5 automatically during the startup of the app and calls the init method once.\n\t\t * @public\n\t\t * @override\n\t\t */\n\t\tinit: function() {\n\t\t\t// call the base component's init function\n\t\t\tUIComponent.prototype.init.apply(this, arguments);\n\n\t\t\t// set the device model\n\t\t\tthis.setModel(models.createDeviceModel(), \"device\");\n\t\t\tthis.getToken();\n\t\t},\n\t\t\n\t\n \n      getToken: function() {\n      \tvar accessToken = '';\n    \tvar baseURI = '';\n\n          var url_base = '/Uber_Login/oauth/v2?client_id%3D1XU7blOR44FyEb49TLha0tnQmLQ6CnUl&response_type%3Dcode&redirect_url=https://uberrides-c82ef9371.dispatcher.ap1.hana.ondemand.com/?hc_reset';\n \n          // The auth_token is the base64 encoded string for the API \n          // application.\n          var auth_token = '1XU7blOR44FyEb49TLha0tnQmLQ6CnUl:XPgwWD9UGRnG4-1hhhV-E79VbgMrdipeOv-ukBj2';\n          auth_token = window.btoa(auth_token);\n          var requestPayload = {\n              'scope': 'history',\n              'redirect_uri' : window.location.host \n          };\n          /*\n          $.ajax({\n              'url': url_base,\n    \t\t'headers': {\n    \t\t\t\"Access-Control-Allow-Origin\": \"*\",\n    \t\t\t\"referer\" : \"https://uberrides-c82ef9371.dispatcher.ap1.hana.ondemand.com/\"\n    \t\t},\n              'success': function (result) {\n                //Process success actions\n                console.log(result);debugger;\n              },\n              'error': function (XMLHttpRequest, textStatus, errorThrown) {\n              \tdebugger;\n              \n              }\n          });*/\n          \n          \n\t    var CLIENT_ID = \"1XU7blOR44FyEb49TLha0tnQmLQ6CnUl\";\n\t    var AUTHORIZATION_ENDPOINT = \"/Uber_Login/oauth/v2/authorize\";\n\t    var RESOURCE_ENDPOINT = \"/Uber_Api/\";\n\t\tvar token;\n\t\t\n\t\n\t      var authUrl = AUTHORIZATION_ENDPOINT + \n\t        \"?response_type=code\" +\n\t        \"&client_id=\"    + CLIENT_ID;\n\t\n\t      window.location.href = authUrl;\n\n\t    }\n          \n       \n   \n\t});\n});",
		"UberRides/view/View1.view.xml": "<mvc:View controllerName=\"UberRides.controller.View1\" xmlns:html=\"http://www.w3.org/1999/xhtml\" xmlns:mvc=\"sap.ui.core.mvc\"\n\tdisplayBlock=\"true\" xmlns=\"sap.m\">\n\t<App>\n\t\t<pages>\n\t\t\t<Page title=\"{i18n>title}\">\n\t\t\t\t<content>\n\t\t\t\t\t<Button press=\"onActionPress\" text=\"Press Me\" /> \n\t\t\t\t</content>\n\t\t\t</Page>\n\t\t</pages>\n\t</App>\n</mvc:View>",
		"UberRides/view/uberLogin.fragment.xml": "<core:FragmentDefinition\n   xmlns=\"sap.m\"\n   xmlns:html=\"http://www.w3.org/1999/xhtml\"\n   xmlns:core=\"sap.ui.core\" >\n   <Dialog\n      id=\"UberLogin\"\n      title=\"Confirmation\">\n   \t\t<content>\n   \t\t\t <html:iframe src=\"/Uber_Login/oauth/v2?client_id%3D1XU7blOR44FyEb49TLha0tnQmLQ6CnUl&response_type%3Dcode\" />\n   \t\t</content>\n   \t\t\t\n    \t<endButton>\n    \t\t<Button\n            text=\"Close\"\n            press=\"onClose\"\n            />\n    \t</endButton>\n   </Dialog>\n</core:FragmentDefinition>",
		"UberRides/controller/View1.controller.js": "sap.ui.define([\n\t\"sap/ui/core/mvc/Controller\",\n\t\"UberRides/util/uber\"\n], function(Controller, Uber) {\n\t\"use strict\";\n\n\treturn Controller.extend(\"UberRides.controller.View1\", {\n\t\tonActionPress: function() {\n\t\t\t\n\t\t\tvar url = \"/Uber_Login/oauth/v2/token?\" +\"client_id=1XU7blOR44FyEb49TLha0tnQmLQ6CnUl&client_secre=XPgwWD9UGRnG4-1hhhV-E79VbgMrdipeOv-ukBj2&grant_type=authorization_code&code= \"+window.token;\n\t\t\t$.ajax({\n\t\t\t\t'url': url,\n\t\t\t\n\t\t\t\t'success': function(XMLHttpRequest, textStatus, result) {\n\t\t\t\t\tdebugger;\n\t\t\t\t},\n\t\t\t\t'error': function(XMLHttpRequest, textStatus, errorThrown) {\n\t\t\t\t\tdebugger;\n\n\t\t\t\t}\n\t\t\t});\n\t\t\t/*\n\t\t\t $.ajax({\n\t      \t'url' : \"/Uber_Api/v1.2/history\",\n\t      \t'headers': {\n\t      \t\t'Content-Type' : 'application/json',\n\t      \t\t'Authorization' : 'Bearer ' +window.token\n\t      \t},\n\t      \t'success': function(XMLHttpRequest, textStatus, result){\n\t      \t\tdebugger;\n\t      \t}\n\t      });\n\t\t\t*/\n\n\t\t}\n\t});\n});",
		"UberRides/model/models.js": "sap.ui.define([\n\t\"sap/ui/model/json/JSONModel\",\n\t\"sap/ui/Device\"\n], function(JSONModel, Device) {\n\t\"use strict\";\n\n\treturn {\n\n\t\tcreateDeviceModel: function() {\n\t\t\tvar oModel = new JSONModel(Device);\n\t\t\toModel.setDefaultBindingMode(\"OneWay\");\n\t\t\treturn oModel;\n\t\t}\n\n\t};\n});"
	}
});